stages:
  - validate
  - build
  - plan
  - deploy-infra
  - deploy-app
  - test

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  TF_ROOT: ${CI_PROJECT_DIR}/terraform
  TF_STATE_NAME: default

.terraform_base:
  image: hashicorp/terraform:1.6
  before_script:
    - cd ${TF_ROOT}
    - terraform init -backend-config="bucket=${TERRAFORM_STATE_BUCKET}" -backend-config="key=${CI_PROJECT_NAME}/terraform.tfstate" -backend-config="region=${AWS_REGION}"

.aws_base:
  before_script:
    - export AWS_DEFAULT_REGION=${AWS_REGION}

# Validate Stage
validate:terraform:
  extends: .terraform_base
  stage: validate
  script:
    - terraform fmt -check
    - terraform validate
  only:
    - branches

validate:docker:
  stage: validate
  image: hadolint/hadolint:latest-alpine
  script:
    - hadolint docker/polaris/Dockerfile
    - hadolint docker/ogc-api/Dockerfile
  only:
    - branches

validate:python:
  stage: validate
  image: python:3.11-slim
  script:
    - cd docker/ogc-api
    - pip install ruff mypy types-requests
    - ruff check app/
    - mypy app/ --ignore-missing-imports
  only:
    - branches

# Build Stage
build:polaris:
  stage: build
  image: docker:24
  services:
    - docker:24-dind
  before_script:
    - apk add --no-cache aws-cli
    - aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com
  script:
    - cd docker/polaris
    - docker build -t ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/polaris-catalog:${CI_COMMIT_SHORT_SHA} .
    - docker build -t ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/polaris-catalog:latest .
    - docker push ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/polaris-catalog:${CI_COMMIT_SHORT_SHA}
    - docker push ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/polaris-catalog:latest
  only:
    - main

build:ogc-api:
  stage: build
  image: docker:24
  services:
    - docker:24-dind
  before_script:
    - apk add --no-cache aws-cli
    - aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com
  script:
    - cd docker/ogc-api
    - docker build -t ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/ogc-api-features:${CI_COMMIT_SHORT_SHA} .
    - docker build -t ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/ogc-api-features:latest .
    - docker push ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/ogc-api-features:${CI_COMMIT_SHORT_SHA}
    - docker push ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/ogc-api-features:latest
  only:
    - main

# Plan Stage
plan:
  extends: .terraform_base
  stage: plan
  script:
    - terraform plan -out=tfplan
  artifacts:
    paths:
      - ${TF_ROOT}/tfplan
    expire_in: 1 week
  only:
    - main

# Deploy Infrastructure Stage
deploy:infrastructure:
  extends: .terraform_base
  stage: deploy-infra
  script:
    - terraform apply -auto-approve tfplan
    - terraform output -json > ${CI_PROJECT_DIR}/tf_outputs.json
  artifacts:
    paths:
      - tf_outputs.json
    expire_in: 1 week
  when: manual
  only:
    - main
  dependencies:
    - plan

# Deploy Application Stage
deploy:application:
  stage: deploy-app
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client aws-cli jq bash
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan -H $(jq -r '.ec2_public_ip.value' tf_outputs.json) >> ~/.ssh/known_hosts
  script:
    - export EC2_IP=$(jq -r '.ec2_public_ip.value' tf_outputs.json)
    - export S3_BUCKET=$(jq -r '.s3_bucket_name.value' tf_outputs.json)
    - export DYNAMODB_TABLE=$(jq -r '.dynamodb_table_name.value' tf_outputs.json)
    - export ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
    - |
      ssh -o StrictHostKeyChecking=no ec2-user@${EC2_IP} << 'ENDSSH'
        # Login to ECR
        aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${ECR_REGISTRY}
        
        # Create deployment directory
        mkdir -p ~/deployment
        cd ~/deployment
      ENDSSH
    - |
      # Generate docker-compose.yml from template
      envsubst < docker/docker-compose.yml.template > docker-compose.yml
      scp docker-compose.yml ec2-user@${EC2_IP}:~/deployment/
    - |
      ssh -o StrictHostKeyChecking=no ec2-user@${EC2_IP} << 'ENDSSH'
        cd ~/deployment
        
        # Pull latest images
        docker-compose pull
        
        # Stop existing containers
        docker-compose down
        
        # Start services
        docker-compose up -d
        
        # Wait for health checks
        echo "Waiting for services to be healthy..."
        sleep 30
        
        # Check service status
        docker-compose ps
      ENDSSH
    - bash scripts/health_check.sh ${EC2_IP}
  when: manual
  only:
    - main
  dependencies:
    - deploy:infrastructure

# Test Stage
test:smoke:
  stage: test
  image: curlimages/curl:latest
  script:
    - export EC2_IP=$(jq -r '.ec2_public_ip.value' tf_outputs.json)
    - echo "Testing Polaris catalog..."
    - curl -f http://${EC2_IP}:8181/v1/config || exit 1
    - echo "Testing OGC API landing page..."
    - curl -f http://${EC2_IP}:8080/ || exit 1
    - echo "Testing OGC API conformance..."
    - curl -f http://${EC2_IP}:8080/conformance || exit 1
    - echo "Testing OGC API collections..."
    - curl -f http://${EC2_IP}:8080/collections || exit 1
    - echo "All smoke tests passed!"
  dependencies:
    - deploy:infrastructure
  only:
    - main