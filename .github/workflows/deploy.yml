name: Deploy Geospatial Platform

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  AWS_REGION: us-west-2
  TF_VERSION: 1.6.0

jobs:
  validate:
    name: Validate
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Format Check
        run: |
          cd terraform
          terraform fmt -check

      - name: Terraform Init
        run: |
          cd terraform
          terraform init -backend=false

      - name: Terraform Validate
        run: |
          cd terraform
          terraform validate

      - name: Lint Dockerfiles
        uses: hadolint/hadolint-action@v3.1.0
        with:
          dockerfile: docker/polaris/Dockerfile

      - name: Lint OGC API Dockerfile
        uses: hadolint/hadolint-action@v3.1.0
        with:
          dockerfile: docker/ogc-api/Dockerfile
          ignore: DL3008

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Lint Python Code
        run: |
          cd docker/ogc-api
          pip install ruff mypy types-requests
          ruff check app/ || true
          mypy app/ --ignore-missing-imports || true

  build:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: validate
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: linux/amd64,linux/arm64

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Create ECR repositories if they don't exist
        run: |
          aws ecr describe-repositories --repository-names polaris-catalog --region ${{ env.AWS_REGION }} || \
            aws ecr create-repository --repository-name polaris-catalog --region ${{ env.AWS_REGION }}
          
          aws ecr describe-repositories --repository-names ogc-api-features --region ${{ env.AWS_REGION }} || \
            aws ecr create-repository --repository-name ogc-api-features --region ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and Push Polaris Image (Multi-arch)
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          cd docker/polaris
          
          echo "Building multi-architecture image for linux/amd64 and linux/arm64..."
          
          docker buildx build \
            --platform linux/amd64,linux/arm64 \
            --tag $ECR_REGISTRY/polaris-catalog:$IMAGE_TAG \
            --tag $ECR_REGISTRY/polaris-catalog:latest \
            --push \
            --progress=plain \
            .
          
          echo "✅ Polaris multi-arch image built and pushed"

      - name: Build and Push OGC API Image (Multi-arch)
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          cd docker/ogc-api
          
          echo "Building multi-architecture image for linux/amd64 and linux/arm64..."
          
          docker buildx build \
            --platform linux/amd64,linux/arm64 \
            --tag $ECR_REGISTRY/ogc-api-features:$IMAGE_TAG \
            --tag $ECR_REGISTRY/ogc-api-features:latest \
            --push \
            --progress=plain \
            .
          
          echo "✅ OGC API multi-arch image built and pushed"

  plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Terraform Init
        run: |
          cd terraform
          terraform init \
            -backend-config="bucket=${{ secrets.TERRAFORM_STATE_BUCKET }}" \
            -backend-config="key=iceberg-test-deployment/terraform.tfstate" \
            -backend-config="region=${{ secrets.AWS_REGION }}"

      - name: Terraform Plan
        run: |
          cd terraform
          terraform plan -out=tfplan

      - name: Upload Plan
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan
          path: terraform/tfplan
          retention-days: 5

  deploy-infra:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: plan
    if: github.ref == 'refs/heads/main'
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Terraform Init
        run: |
          cd terraform
          terraform init \
            -backend-config="bucket=${{ secrets.TERRAFORM_STATE_BUCKET }}" \
            -backend-config="key=iceberg-test-deployment/terraform.tfstate" \
            -backend-config="region=${{ secrets.AWS_REGION }}"

      - name: Download Plan
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan
          path: terraform/

      - name: Import existing ECR repositories
        working-directory: terraform
        run: |
          terraform import aws_ecr_repository.polaris polaris-catalog || true
          terraform import aws_ecr_repository.ogc_api ogc-api-features || true
        continue-on-error: true

      - name: Terraform Apply
        working-directory: terraform
        run: terraform apply -auto-approve

      - name: Get Terraform Outputs
        id: tf-outputs
        run: |
          cd terraform
          echo "ec2_public_ip=$(terraform output -raw ec2_public_ip)" >> $GITHUB_OUTPUT
          echo "ec2_instance_id=$(terraform output -raw ec2_instance_id)" >> $GITHUB_OUTPUT
          echo "s3_bucket=$(terraform output -raw s3_bucket_name)" >> $GITHUB_OUTPUT
          echo "dynamodb_table=$(terraform output -raw dynamodb_table_name)" >> $GITHUB_OUTPUT
          terraform output -json > ../tf_outputs.json

      - name: Upload Terraform Outputs
        uses: actions/upload-artifact@v4
        with:
          name: terraform-outputs
          path: tf_outputs.json
          retention-days: 30

  verify-security-groups:
    name: Verify Security Groups
    runs-on: ubuntu-latest
    needs: deploy-infra
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Download Terraform Outputs
        uses: actions/download-artifact@v4
        with:
          name: terraform-outputs

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Verify and Attach Security Group
        run: |
          set -e
          
          EC2_IP=$(jq -r '.ec2_public_ip.value' tf_outputs.json)
          INSTANCE_ID=$(jq -r '.ec2_instance_id.value' tf_outputs.json)
          
          echo "Instance ID: $INSTANCE_ID"
          echo "Instance IP: $EC2_IP"
          
          # Get security group ID
          echo "Finding security group..."
          SG_ID=$(aws ec2 describe-security-groups \
            --filters "Name=tag:Name,Values=iceberg-test-sg" \
            --query 'SecurityGroups[0].GroupId' \
            --output text)
          
          if [ "$SG_ID" == "None" ] || [ -z "$SG_ID" ]; then
            echo "❌ Error: Security group not found!"
            exit 1
          fi
          
          echo "Security Group ID: $SG_ID"
          
          # Check if security group is already attached
          echo "Checking security group attachment..."
          CURRENT_SGS=$(aws ec2 describe-instances \
            --instance-ids $INSTANCE_ID \
            --query 'Reservations[0].Instances[0].SecurityGroups[*].GroupId' \
            --output json)
          
          echo "Current security groups: $CURRENT_SGS"
          
          if echo "$CURRENT_SGS" | grep -q "$SG_ID"; then
            echo "✅ Security group already attached"
          else
            echo "⚠️  Security group not attached, attaching now..."
            aws ec2 modify-instance-attribute \
              --instance-id $INSTANCE_ID \
              --groups $SG_ID
            
            echo "✅ Security group attached"
            echo "Waiting 15 seconds for changes to propagate..."
            sleep 15
          fi
          
          # Verify security group rules exist
          echo "Verifying security group rules..."
          RULES=$(aws ec2 describe-security-groups \
            --group-ids $SG_ID \
            --query 'SecurityGroups[0].IpPermissions[?FromPort==`8181` || FromPort==`8080`].[FromPort,ToPort,IpRanges[0].CidrIp]' \
            --output text)
          
          echo "Security group rules for ports 8080/8181:"
          echo "$RULES"
          
          if [ -z "$RULES" ]; then
            echo "⚠️  Warning: No rules found for ports 8080/8181"
          fi
          
          # Final verification
          echo "Final security group check..."
          aws ec2 describe-instances \
            --instance-ids $INSTANCE_ID \
            --query 'Reservations[0].Instances[0].{SecurityGroups:SecurityGroups[*].[GroupId,GroupName]}' \
            --output json
          
          echo "✅ Security group verification complete"

  deploy-app:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: verify-security-groups
    if: github.ref == 'refs/heads/main'
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Terraform Outputs
        uses: actions/download-artifact@v4
        with:
          name: terraform-outputs

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Get EC2 Details
        id: ec2-details
        run: |
          EC2_IP=$(jq -r '.ec2_public_ip.value' tf_outputs.json)
          EC2_INSTANCE_ID=$(jq -r '.ec2_instance_id.value' tf_outputs.json)
          S3_BUCKET=$(jq -r '.s3_bucket_name.value' tf_outputs.json)
          DYNAMODB_TABLE=$(jq -r '.dynamodb_table_name.value' tf_outputs.json)
          echo "ec2_ip=$EC2_IP" >> $GITHUB_OUTPUT
          echo "ec2_instance_id=$EC2_INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "s3_bucket=$S3_BUCKET" >> $GITHUB_OUTPUT
          echo "dynamodb_table=$DYNAMODB_TABLE" >> $GITHUB_OUTPUT

      - name: Wait for SSM Agent
        run: |
          echo "Waiting for SSM agent to be ready..."
          for i in {1..30}; do
            STATUS=$(aws ssm describe-instance-information \
              --filters "Key=InstanceIds,Values=${{ steps.ec2-details.outputs.ec2_instance_id }}" \
              --query "InstanceInformationList[0].PingStatus" \
              --output text 2>/dev/null || echo "NotFound")
            
            if [ "$STATUS" == "Online" ]; then
              echo "SSM agent is online!"
              break
            fi
            echo "Attempt $i/30: SSM agent status is $STATUS, waiting..."
            sleep 10
          done

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Generate docker-compose.yml
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          S3_BUCKET: ${{ steps.ec2-details.outputs.s3_bucket }}
          DYNAMODB_TABLE: ${{ steps.ec2-details.outputs.dynamodb_table }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          envsubst < docker/docker-compose.yml.template > docker-compose.yml
          cat docker-compose.yml

      - name: Copy docker-compose.yml to S3
        run: |
          aws s3 cp docker-compose.yml s3://${{ steps.ec2-details.outputs.s3_bucket }}/deployment/docker-compose.yml

      - name: Deploy to EC2 via SSM
        env:
          INSTANCE_ID: ${{ steps.ec2-details.outputs.ec2_instance_id }}
          S3_BUCKET: ${{ steps.ec2-details.outputs.s3_bucket }}
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          # Stage 1: Setup and download
          echo "=== Stage 1: Setup ==="
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "mkdir -p ~/deployment",
              "cd ~/deployment",
              "aws s3 cp s3://'"$S3_BUCKET"'/deployment/docker-compose.yml .",
              "cat docker-compose.yml"
            ]' \
            --region "$AWS_REGION" \
            --output text \
            --query "Command.CommandId")
          
          aws ssm wait command-executed --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --region "$AWS_REGION"
          
          STATUS=$(aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --region "$AWS_REGION" --query "Status" --output text)
          if [ "$STATUS" != "Success" ]; then
            echo "Setup failed!"
            aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --region "$AWS_REGION" --query "StandardErrorContent" --output text
            exit 1
          fi
          echo "✅ Setup complete"
          
          # Stage 2: ECR Login and Pull
          echo "=== Stage 2: Pull Images ==="
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --timeout-seconds 600 \
            --parameters 'commands=[
              "cd ~/deployment",
              "aws ecr get-login-password --region '"$AWS_REGION"' | docker login --username AWS --password-stdin '"$ECR_REGISTRY"'",
              "docker-compose pull 2>&1 | tail -20"
            ]' \
            --region "$AWS_REGION" \
            --output text \
            --query "Command.CommandId")
          
          aws ssm wait command-executed --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --region "$AWS_REGION"
          
          STATUS=$(aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --region "$AWS_REGION" --query "Status" --output text)
          if [ "$STATUS" != "Success" ]; then
            echo "Pull failed!"
            aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --region "$AWS_REGION" --query "StandardErrorContent" --output text
            exit 1
          fi
          echo "✅ Images pulled"
          
          # Stage 3: Deploy
          echo "=== Stage 3: Deploy Containers ==="
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "cd ~/deployment",
              "docker-compose down || true",
              "docker-compose up -d",
              "sleep 10",
              "docker-compose ps",
              "docker-compose logs --tail=20"
            ]' \
            --region "$AWS_REGION" \
            --output text \
            --query "Command.CommandId")
          
          aws ssm wait command-executed --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --region "$AWS_REGION"
          
          STATUS=$(aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --region "$AWS_REGION" --query "Status" --output text)
          
          echo "=== Container Output ==="
          aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --region "$AWS_REGION" --query "StandardOutputContent" --output text | tail -50
          
          if [ "$STATUS" != "Success" ]; then
            echo "Deployment failed!"
            aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --region "$AWS_REGION" --query "StandardErrorContent" --output text
            exit 1
          fi
          
          echo "✅ Deployment complete"

      - name: Health Check
        env:
          EC2_IP: ${{ steps.ec2-details.outputs.ec2_ip }}
        run: |
          echo "Testing Polaris catalog..."
          curl -f http://${EC2_IP}:8181/v1/config || echo "Polaris not ready yet"
          
          echo "Testing OGC API landing page..."
          curl -f http://${EC2_IP}:8080/ || echo "OGC API not ready yet"
          
          echo "Services may still be starting up..."

  test:
    name: Smoke Tests
    runs-on: ubuntu-latest
    needs: deploy-app
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Terraform Outputs
        uses: actions/download-artifact@v4
        with:
          name: terraform-outputs

      - name: Wait for Services with Retry
        run: |
          EC2_IP=$(jq -r '.ec2_public_ip.value' tf_outputs.json)
          MAX_RETRIES=30
          RETRY_DELAY=10
          
          echo "Waiting for Polaris to become available at http://${EC2_IP}:8181..."
          
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $i/$MAX_RETRIES..."
            
            if curl -f -s -o /dev/null http://${EC2_IP}:8181/v1/config; then
              echo "✅ Polaris is available!"
              break
            fi
            
            if [ $i -eq $MAX_RETRIES ]; then
              echo "❌ Polaris failed to become available after $((MAX_RETRIES * RETRY_DELAY)) seconds"
              echo "Checking security group..."
              exit 1
            fi
            
            echo "Polaris not ready yet, waiting ${RETRY_DELAY} seconds..."
            sleep $RETRY_DELAY
          done
          
          echo "Waiting for OGC API to become available at http://${EC2_IP}:8080..."
          
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $i/$MAX_RETRIES..."
            
            if curl -f -s -o /dev/null http://${EC2_IP}:8080/; then
              echo "✅ OGC API is available!"
              break
            fi
            
            if [ $i -eq $MAX_RETRIES ]; then
              echo "❌ OGC API failed to become available after $((MAX_RETRIES * RETRY_DELAY)) seconds"
              exit 1
            fi
            
            echo "OGC API not ready yet, waiting ${RETRY_DELAY} seconds..."
            sleep $RETRY_DELAY
          done

      - name: Run Smoke Tests
        run: |
          EC2_IP=$(jq -r '.ec2_public_ip.value' tf_outputs.json)
          
          echo "Testing Polaris catalog..."
          curl -f http://${EC2_IP}:8181/v1/config || exit 1
          echo "✅ Polaris test passed"
          
          echo "Testing OGC API landing page..."
          curl -f http://${EC2_IP}:8080/ || exit 1
          echo "✅ OGC API landing page test passed"
          
          echo "Testing OGC API conformance..."
          curl -f http://${EC2_IP}:8080/conformance || exit 1
          echo "✅ OGC API conformance test passed"
          
          echo "Testing OGC API collections..."
          curl -f http://${EC2_IP}:8080/collections || exit 1
          echo "✅ OGC API collections test passed"
          
          echo "🎉 All smoke tests passed!"