name: Deploy Geospatial Platform

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  AWS_REGION: us-west-2
  TF_VERSION: 1.6.0

jobs:
  validate:
    name: Validate
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Format Check
        run: |
          cd terraform
          terraform fmt -check

      - name: Terraform Init
        run: |
          cd terraform
          terraform init -backend=false

      - name: Terraform Validate
        run: |
          cd terraform
          terraform validate

      - name: Lint Dockerfiles
        uses: hadolint/hadolint-action@v3.1.0
        with:
          dockerfile: docker/polaris/Dockerfile

      - name: Lint OGC API Dockerfile
        uses: hadolint/hadolint-action@v3.1.0
        with:
          dockerfile: docker/ogc-api/Dockerfile
          ignore: DL3008

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Lint Python Code
        run: |
          cd docker/ogc-api
          pip install ruff mypy types-requests
          ruff check app/ || true
          mypy app/ --ignore-missing-imports || true

  build:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: validate
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Create ECR repositories if they don't exist
        run: |
          aws ecr describe-repositories --repository-names polaris-catalog --region ${{ env.AWS_REGION }} || \
            aws ecr create-repository --repository-name polaris-catalog --region ${{ env.AWS_REGION }}
        
          aws ecr describe-repositories --repository-names ogc-api-features --region ${{ env.AWS_REGION }} || \
            aws ecr create-repository --repository-name ogc-api-features --region ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and Push Polaris Image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          cd docker/polaris
          docker build -t $ECR_REGISTRY/polaris-catalog:$IMAGE_TAG .
          docker build -t $ECR_REGISTRY/polaris-catalog:latest .
          docker push $ECR_REGISTRY/polaris-catalog:$IMAGE_TAG
          docker push $ECR_REGISTRY/polaris-catalog:latest

      - name: Build and Push OGC API Image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          cd docker/ogc-api
          docker build -t $ECR_REGISTRY/ogc-api-features:$IMAGE_TAG .
          docker build -t $ECR_REGISTRY/ogc-api-features:latest .
          docker push $ECR_REGISTRY/ogc-api-features:$IMAGE_TAG
          docker push $ECR_REGISTRY/ogc-api-features:latest

  plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Terraform Init
        run: |
          cd terraform
          terraform init \
            -backend-config="bucket=${{ secrets.TERRAFORM_STATE_BUCKET }}" \
            -backend-config="key=iceberg-test-deployment/terraform.tfstate" \
            -backend-config="region=${{ secrets.AWS_REGION }}"

      - name: Terraform Plan
        run: |
          cd terraform
          terraform plan -out=tfplan

      - name: Upload Plan
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan
          path: terraform/tfplan
          retention-days: 5

  deploy-infra:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: plan
    if: github.ref == 'refs/heads/main'
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Terraform Init
        run: |
          cd terraform
          terraform init \
            -backend-config="bucket=${{ secrets.TERRAFORM_STATE_BUCKET }}" \
            -backend-config="key=iceberg-test-deployment/terraform.tfstate" \
            -backend-config="region=${{ secrets.AWS_REGION }}"

      - name: Download Plan
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan
          path: terraform/

      - name: Import existing ECR repositories
        working-directory: terraform
        run: |
          terraform import aws_ecr_repository.polaris polaris-catalog || true
          terraform import aws_ecr_repository.ogc_api ogc-api-features || true
        continue-on-error: true

      - name: Terraform Apply
        working-directory: terraform
        run: terraform apply -auto-approve

      - name: Get Terraform Outputs
        id: tf-outputs
        run: |
          cd terraform
          echo "ec2_public_ip=$(terraform output -raw ec2_public_ip)" >> $GITHUB_OUTPUT
          echo "ec2_instance_id=$(terraform output -raw ec2_instance_id)" >> $GITHUB_OUTPUT
          echo "s3_bucket=$(terraform output -raw s3_bucket_name)" >> $GITHUB_OUTPUT
          echo "dynamodb_table=$(terraform output -raw dynamodb_table_name)" >> $GITHUB_OUTPUT
          terraform output -json > ../tf_outputs.json

      - name: Upload Terraform Outputs
        uses: actions/upload-artifact@v4
        with:
          name: terraform-outputs
          path: tf_outputs.json
          retention-days: 30

  deploy-app:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: deploy-infra
    if: github.ref == 'refs/heads/main'
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Terraform Outputs
        uses: actions/download-artifact@v4
        with:
          name: terraform-outputs

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Get EC2 Details
        id: ec2-details
        run: |
          EC2_IP=$(jq -r '.ec2_public_ip.value' tf_outputs.json)
          EC2_INSTANCE_ID=$(jq -r '.ec2_instance_id.value' tf_outputs.json)
          S3_BUCKET=$(jq -r '.s3_bucket_name.value' tf_outputs.json)
          DYNAMODB_TABLE=$(jq -r '.dynamodb_table_name.value' tf_outputs.json)
          echo "ec2_ip=$EC2_IP" >> $GITHUB_OUTPUT
          echo "ec2_instance_id=$EC2_INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "s3_bucket=$S3_BUCKET" >> $GITHUB_OUTPUT
          echo "dynamodb_table=$DYNAMODB_TABLE" >> $GITHUB_OUTPUT

      - name: Wait for SSM Agent
        run: |
          echo "Waiting for SSM agent to be ready..."
          for i in {1..30}; do
            STATUS=$(aws ssm describe-instance-information \
              --filters "Key=InstanceIds,Values=${{ steps.ec2-details.outputs.ec2_instance_id }}" \
              --query "InstanceInformationList[0].PingStatus" \
              --output text 2>/dev/null || echo "NotFound")
            
            if [ "$STATUS" == "Online" ]; then
              echo "SSM agent is online!"
              break
            fi
            echo "Attempt $i/30: SSM agent status is $STATUS, waiting..."
            sleep 10
          done

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Generate docker-compose.yml
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          S3_BUCKET: ${{ steps.ec2-details.outputs.s3_bucket }}
          DYNAMODB_TABLE: ${{ steps.ec2-details.outputs.dynamodb_table }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          envsubst < docker/docker-compose.yml.template > docker-compose.yml
          cat docker-compose.yml

      - name: Copy docker-compose.yml to S3
        run: |
          aws s3 cp docker-compose.yml s3://${{ steps.ec2-details.outputs.s3_bucket }}/deployment/docker-compose.yml

      - name: Deploy to EC2 via SSM
        env:
          INSTANCE_ID: ${{ steps.ec2-details.outputs.ec2_instance_id }}
          S3_BUCKET: ${{ steps.ec2-details.outputs.s3_bucket }}
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          # Stage 1: Setup and download
          echo "=== Stage 1: Setup ==="
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "mkdir -p ~/deployment",
              "cd ~/deployment",
              "aws s3 cp s3://'"$S3_BUCKET"'/deployment/docker-compose.yml .",
              "cat docker-compose.yml"
            ]' \
            --region "$AWS_REGION" \
            --output text \
            --query "Command.CommandId")
          
          aws ssm wait command-executed --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --region "$AWS_REGION"
          
          STATUS=$(aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --region "$AWS_REGION" --query "Status" --output text)
          if [ "$STATUS" != "Success" ]; then
            echo "Setup failed!"
            aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --region "$AWS_REGION" --query "StandardErrorContent" --output text
            exit 1
          fi
          echo "✅ Setup complete"
          
          # Stage 2: ECR Login and Pull
          echo "=== Stage 2: Pull Images ==="
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --timeout-seconds 600 \
            --parameters 'commands=[
              "cd ~/deployment",
              "aws ecr get-login-password --region '"$AWS_REGION"' | docker login --username AWS --password-stdin '"$ECR_REGISTRY"'",
              "docker-compose pull 2>&1 | tail -20"
            ]' \
            --region "$AWS_REGION" \
            --output text \
            --query "Command.CommandId")
          
          aws ssm wait command-executed --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --region "$AWS_REGION"
          
          STATUS=$(aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --region "$AWS_REGION" --query "Status" --output text)
          if [ "$STATUS" != "Success" ]; then
            echo "Pull failed!"
            aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --region "$AWS_REGION" --query "StandardErrorContent" --output text
            exit 1
          fi
          echo "✅ Images pulled"
          
          # Stage 3: Deploy
          echo "=== Stage 3: Deploy Containers ==="
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "cd ~/deployment",
              "docker-compose down || true",
              "docker-compose up -d",
              "sleep 10",
              "docker-compose ps",
              "docker-compose logs --tail=20"
            ]' \
            --region "$AWS_REGION" \
            --output text \
            --query "Command.CommandId")
          
          aws ssm wait command-executed --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --region "$AWS_REGION"
          
          STATUS=$(aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --region "$AWS_REGION" --query "Status" --output text)
          
          echo "=== Container Output ==="
          aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --region "$AWS_REGION" --query "StandardOutputContent" --output text | tail -50
          
          if [ "$STATUS" != "Success" ]; then
            echo "Deployment failed!"
            aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --region "$AWS_REGION" --query "StandardErrorContent" --output text
            exit 1
          fi
          
          echo "✅ Deployment complete"

      - name: Health Check
        env:
          EC2_IP: ${{ steps.ec2-details.outputs.ec2_ip }}
        run: |
          echo "Testing Polaris catalog..."
          curl -f http://${EC2_IP}:8181/v1/config || echo "Polaris not ready yet"
          
          echo "Testing OGC API landing page..."
          curl -f http://${EC2_IP}:8080/ || echo "OGC API not ready yet"
          
          echo "Services may still be starting up..."

  test:
    name: Smoke Tests
    runs-on: ubuntu-latest
    needs: deploy-app
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Terraform Outputs
        uses: actions/download-artifact@v4
        with:
          name: terraform-outputs

      - name: Run Smoke Tests
        run: |
          EC2_IP=$(jq -r '.ec2_public_ip.value' tf_outputs.json)
          
          echo "Waiting 60 seconds for services to fully start..."
          sleep 60
          
          echo "Testing Polaris catalog..."
          curl -f http://${EC2_IP}:8181/v1/config || exit 1
          
          echo "Testing OGC API landing page..."
          curl -f http://${EC2_IP}:8080/ || exit 1
          
          echo "Testing OGC API conformance..."
          curl -f http://${EC2_IP}:8080/conformance || exit 1
          
          echo "Testing OGC API collections..."
          curl -f http://${EC2_IP}:8080/collections || exit 1
          
          echo "All smoke tests passed!"